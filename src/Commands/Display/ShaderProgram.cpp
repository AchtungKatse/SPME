#include "Commands/Display/ShaderProgram.h"
#include "glm/ext.hpp"
#include "glm/glm.hpp"

namespace SPMEditor 
{
    ShaderProgram::ShaderProgram() : 
        m_ShaderName(0),
        m_ShaderProgramId(-1)
    { }

    ShaderProgram::ShaderProgram(const char* programName, std::initializer_list<Shader> shaders) :
        m_ShaderName(programName),
        m_UseRenderContext(true)
    {
        while (glGetError());

        m_ShaderProgramId = glCreateProgram();
        LogTrace("Creating shader program %s with ID: %u", programName, m_ShaderProgramId);
        for (const Shader& shader : shaders)
        {
            LogTrace("\tLinking Shader ID %u", shader.m_ShaderIndex);
            glAttachShader(m_ShaderProgramId, shader.m_ShaderIndex);

            uint error = glGetError();
            while (error)
            {
                switch (error)
                {
                    case GL_INVALID_VALUE:
                        LogError("Shader Program %u failed to attach shader %u. Invalid value. Program or shader not generated by opengl.", m_ShaderProgramId, shader.m_ShaderIndex);
                        break;
                    case GL_INVALID_OPERATION:
                        LogError("Shader Program %u failed to attach shader %u. Invalid operation. \n\tProgram / shader not protram / shader object.\n\tShader may already be attached.", m_ShaderProgramId, shader.m_ShaderIndex);
                        break;
                }

                error = glGetError();
            }
        }
        glLinkProgram(m_ShaderProgramId);

        uint error = glGetError();
        while (error)
        {
            switch (error)
            {
                case GL_INVALID_VALUE:
                    LogError("Shader Program %u failed to link. Invalid value. Program not generated by opengl.", m_ShaderProgramId);
                    break;
                case GL_INVALID_OPERATION:
                    LogError("Shader Program %u failed to link. Invalid operation. \n\tProgram not a program object or  program is the currently active program object and transform feedback mode is active.", m_ShaderProgramId);
                    break;
            }

            error = glGetError();
        }

        int success = 0;
        int logSize;
        glGetProgramiv(m_ShaderProgramId, GL_INFO_LOG_LENGTH, &logSize);

        char infoLog[logSize];
        memset(infoLog, 0, logSize);
        glGetProgramiv(m_ShaderProgramId, GL_LINK_STATUS, &success);
        if (!success)
        {
            glGetProgramInfoLog(m_ShaderProgramId, logSize, NULL, infoLog);
            LogError("Failed to link shader '%s': %s \n\tError Length: %d", programName, (char*)infoLog, logSize);
        }
        else
        {
            LogTrace("\tProgram %s (%u) Linked successfully", programName, m_ShaderProgramId);
        }

        int uniformCount;
        glGetProgramiv(m_ShaderProgramId, GL_ACTIVE_UNIFORMS, &uniformCount);
        for (int i = 0; i < uniformCount; i++)
        {
            constexpr int MaxNameLength = 32;
            char name[MaxNameLength];

            memset(name, 0, MaxNameLength);
            int length;
            int varSize;
            GLenum type;
            glGetActiveUniform(m_ShaderProgramId, i, MaxNameLength, &length, &varSize, &type, name);

            LogTrace("\tFound uniform '%s' with type %u", name, type);
            m_UniformLocations.emplace(std::make_pair(name, i));
        }

        for (const auto& uniformLocation : m_UniformLocations)
        {
            LogTrace("\tUniform %u: (%s, %u)", m_UniformLocations.size(), uniformLocation.first.c_str(), uniformLocation.second);
        }
    }

    ShaderProgram::~ShaderProgram()
    {
    }

    void ShaderProgram::UseProgram()
    { 
        glUseProgram(m_ShaderProgramId); 
    }

    GLuint ShaderProgram::GetUniform(const char* name)
    {
        if (m_UniformLocations.contains(name))
        {
            return m_UniformLocations[name];
        }

        while (glGetError()) { }
        GLuint location = glGetUniformLocation(m_ShaderProgramId, name);
        m_UniformLocations[name] = location;
        return location;
    }

    void ShaderProgram::SetUniformMatrix4fv(const char* name, const glm::mat4& matrix)
    {
        glUniformMatrix4fv(GetUniform(name), 1, GL_FALSE, glm::value_ptr(matrix));
    }


    void ShaderProgram::SetUniformMatrix3fv(const char* name, const glm::mat3& matrix)
    {
        glUniformMatrix4fv(GetUniform(name), 1, GL_FALSE, glm::value_ptr(matrix));
    }

    void ShaderProgram::SetUniformInt(const char* name, int value)
    {
        glUniform1i(GetUniform(name), value);
    }

    void ShaderProgram::SetUniformUInt(const char* name, uint value)
    {
        glUniform1ui(GetUniform(name), value);
    }

    void ShaderProgram::SetUniformFloat(const char* name, float value)
    {
        glUniform1f(GetUniform(name), value);
    }

    void ShaderProgram::SetUniformVector2(const char* name, Vector2 value)
    {
        glUniform2fv(GetUniform(name), 1, (float*)&value);
    }

    void ShaderProgram::SetUniformVector3i(const char* name, Vector3i value)
    {
        GLuint location = GetUniform(name);
        glUniform3iv(location, 1, (int*)&value);
    }

    void ShaderProgram::SetUniformVector3(const char* name, Vector3 value)
    {
        glUniform3fv(GetUniform(name), 1, (float*)&value);
    }

    /*void ShaderProgram::SetUniformVector4(const char* name, Vector4 value)*/
    /*{*/
    /*    glUniform4fv(GetUniform(name), 1, (float*)&value);*/
    /*}*/
}

